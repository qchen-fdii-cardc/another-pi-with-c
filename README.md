# another-pi-with-c
Another c app to calculate pi

## Overview

This application demonstrates three different mathematical approaches to calculating the value of pi, each utilizing distinct computational strategies with varying convergence rates and accuracy characteristics. The implementation showcases how different numerical methods can be applied to solve the same mathematical problem, providing insights into their relative performance and precision.

## Mathematical Methods

The program implements three well-established algorithms for computing pi, each with its own theoretical foundation and practical considerations. The Leibniz formula represents one of the earliest infinite series approaches to calculating pi, though it converges relatively slowly compared to more modern methods. This method is based on the Gregory-Leibniz series, which expresses pi divided by four as an alternating sum of reciprocals of odd numbers. Specifically, the formula states that pi/4 equals 1 minus 1/3 plus 1/5 minus 1/7 plus 1/9, and so on, continuing indefinitely. While elegant in its simplicity, this method requires a substantial number of iterations to achieve high precision due to its slow convergence rate.

The Nilakantha series offers a significantly faster convergence compared to the Leibniz formula, making it a more practical choice for applications requiring higher accuracy with fewer iterations. This method starts with an initial approximation of 3 and then adds or subtracts terms involving products of consecutive even numbers. The series takes the form of pi equals 3 plus 4 divided by the product of 2, 3, and 4, minus 4 divided by the product of 4, 5, and 6, plus 4 divided by the product of 6, 7, and 8, and so forth. Each term contributes more significantly to the final result than the corresponding term in the Leibniz series, allowing for faster convergence to the true value of pi.

The Monte Carlo method represents a completely different approach based on probabilistic sampling rather than infinite series summation. This technique leverages random number generation to estimate pi by simulating the relationship between the area of a circle and its enclosing square. The algorithm generates random points within a unit square and determines what proportion of these points fall within a quarter circle inscribed in that square. Since the ratio of the area of a quarter circle to the area of the unit square equals pi divided by 4, multiplying the proportion of points inside the circle by 4 yields an approximation of pi. While this method is conceptually straightforward and demonstrates the power of stochastic simulation, its accuracy depends heavily on the quality of the random number generator and typically requires a very large number of samples to achieve precision comparable to the deterministic series methods.

## Calculating More Digits of Pi

Beyond the iterative series methods described above, this application also implements the Rabinowitz and Wagon spigot algorithm, a remarkable digit-extraction technique that generates the decimal digits of pi sequentially without requiring floating-point arithmetic or trigonometric functions. Unlike the series-based approaches that compute pi as a single approximation value with limited precision, the spigot algorithm produces digits one at a time in order, making it particularly elegant for applications that need a specific number of exact digits.

The spigot algorithm operates by maintaining an array of integers that represents an intermediate state in the computation, with each position in the array corresponding to a term in a particular mathematical series representation. At its core, the algorithm performs a sequence of transformations on this array, where each transformation extracts one decimal digit of pi while preparing the state for extracting the next digit. The process begins by initializing the array with the value 2 in each position, which corresponds to the initial conditions of the underlying mathematical series. The length of this array is carefully chosen to be approximately (10/3) times the number of desired digits plus 2, a ratio that emerges from the convergence properties of the series being computed.

For each digit to be extracted, the algorithm performs a backward sweep through the array, starting from the highest index and working toward the beginning. During this sweep, each array element is multiplied by 10 and combined with a carry value from the previous position, creating a numerator that is then divided by a denominator based on the position index. Specifically, for position j, the denominator is 2j plus 1, reflecting the structure of the underlying series. The division produces a new carry value that propagates to the next position, while the remainder is stored back into the array. After completing the sweep, the carry value accumulated at the front of the array contains information that yields the next digit of pi, with appropriate adjustments to handle the integer representation.

This algorithm is particularly efficient for generating a moderate number of digits, as implemented in this application where it produces ten thousand digits by default. The time complexity for extracting n digits grows approximately as O(nÂ²) due to the need to process the array for each digit extraction, though generating significantly more digits would eventually require more sophisticated arbitrary-precision arithmetic. The spigot algorithm's deterministic nature and lack of dependence on floating-point precision make it an excellent complement to the probabilistic and series-based methods, demonstrating yet another fascinating approach to computing this fundamental mathematical constant.

To modify the number of digits generated by the spigot algorithm, you can adjust the SPIGOT_DIGITS constant defined in the source code before compilation. Increasing this value will produce more digits of pi, though the computation time and memory requirements will grow correspondingly. The digit extraction is exact within the precision limits of integer arithmetic, providing a reliable reference for comparing the accuracy of the other computational methods implemented in the application.

## Building and Running

To build this application, you'll need a C compiler with math library support. The project uses CMake as its build system, which provides a cross-platform way to generate native build files. Create a build directory, navigate into it, and run CMake to configure the project, then compile the source code using your platform's native build tools. Once compiled, execute the resulting binary to see the pi calculations performed using all three methods simultaneously, with each method using the same number of iterations for comparison purposes. The program will display the computed values alongside the actual value of pi, allowing you to observe the relative accuracy of each approach.
